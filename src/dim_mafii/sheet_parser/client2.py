import datetime
from typing import Dict, List, Optional

import gspread
from singleton_decorator import singleton
from googleapiclient.discovery import build
from gspread import SpreadsheetNotFound
from gspread.models import Worksheet, Spreadsheet, Cell

from dim_mafii import credentials
from dim_mafii.credentials.config import API_NAME, API_VERSION, credentials, LIST_OF_ERRORS_SPREADSHEET
from dim_mafii.domain.types import BlankError


@singleton
class SpreadSheetManager:

    SPREAD_SHEET_ERRORS = LIST_OF_ERRORS_SPREADSHEET

    def __init__(self):
        drive = build(API_NAME, API_VERSION, credentials=credentials)
        self.client = gspread.authorize(credentials)
        self.files = drive.files()

    def drive_file_list(self) -> List:
        """
            Get list of files (with metadata) from Google Drive API
            Default: we check files metadata: id, type, name, permissions
            For response we check only files and pageToken for search
        """
        fields: str = "files(id, mimeType, name, permissions), nextPageToken"  # important for query!
        response = self.files.list(
            orderBy='name, folder',
            fields=fields
        ).execute()

        files_list = response.get('files')
        nextPageToken = response.get('nextPageToken')

        while nextPageToken:
            response = self.files.list(
                orderBy='name, folder',
                fields=fields,
                pageToken=nextPageToken
            ).execute()
            files_list.extend(response.get('files'))
            nextPageToken = response.get('nextPageToken')

        return files_list

    def get_spreadsheets_from_drive(self) -> List:
        files = self.drive_file_list()
        return [
            file for file in files
            if len(file['permissions']) > 1
            and file['mimeType'] == 'application/vnd.google-apps.spreadsheet'
        ]

    def get_map_spreadsheets_id_by_names(self, names: List[str]) -> Dict[str, str]:
        """
        return: {name: id} for every name in list of names which is present on Google Disk
        """
        spreadsheets = self.get_spreadsheets_from_drive()
        return {file['name']: file['id'] for file in spreadsheets if file['name'] in names}

    def get_spreadsheet_by_id(self, id_spreadsheet) -> Optional[Spreadsheet]:
        try:
            return self.client.open_by_key(id_spreadsheet)
        except SpreadsheetNotFound:
            print(f"Not found sheet by id '{id_spreadsheet}'")
            return

    @staticmethod
    def get_absolute_range(title) -> str:
        return f"'{title}'!A1:Z200"

    @classmethod
    def get_matrix_from_sheet(cls, sheet: Spreadsheet) -> Dict[str, List[List]]:
        """
        Return dictionary, when keys - absolute names of worksheets,
        values - matrix from all values in this worksheet
        """
        map_ranges = {cls.get_absolute_range(worksheet.title): worksheet.title for worksheet in sheet.worksheets()}
        response = sheet.values_batch_get(map_ranges.keys())
        """
        response = {
            spreadsheet: '***',
            valueRanges: [
                {
                    ranges: '***',
                    majorDimension: 'ROWS',
                    values: [
                        [],
                        [],
                        [],
                        ...
                    ]
                }
            ]
        }
        """
        worksheets_values = {}
        value_ranges: List[Dict] = response['valueRanges']
        """
        [
            {
                'range': full range of worksheet,
                'majorDimension': 'ROWS',
                'values': [  # NOTE! This key is present when worksheet has values
                    [...],
                    [...],
                    [...],
                    [...], 
                    ...
                ]
            }
        ]
        """

        for worksheet_range in value_ranges:
            if 'values' in worksheet_range:
                worksheet_title = map_ranges[worksheet_range['range']]
                worksheets_values[worksheet_title] = worksheet_range['values']

        return worksheets_values

    @staticmethod
    def get_matrix_for_one_worksheet(worksheet: Worksheet) -> List[List]:
        all_values = worksheet.get_all_values()
        return [row[1:12] for row in all_values[1:46]]

    @staticmethod
    def get_url(url: str) -> str:
        """
        Change URL from API to people-like url

        Url for people
        https://docs.google.com/spreadsheets/d/1ysIAPo7f8yaP72YWjGqz8lcSjRlODgMta0b7fJOFU6g/edit#gid=1583237302

        A URL that was auto-generated by gspread for ez connect with API
        https://sheets.googleapis.com/v4/spreadsheets/1FAuYFo0RVulE65RnSuvDpwiRIW8PDqY14cqw-RhWGIA#gid=853153179

        """
        id_sheet = url.split('/')[-1]
        return f'https://docs.google.com/spreadsheets/d/{id_sheet}'

    @staticmethod
    def get_sub_matrix(rows: List[List]) -> List[List]:
        max_len = len(max(rows, key=len))
        all_values = [row + [''] * (max_len - len(row)) for row in rows]
        return [row[1:12] for row in all_values[1:46]]

    def write_game_errors(self, errors: List[BlankError], status: str) -> Optional[str]:
        """
        Errors: BlankError with attributes:
            spreadsheet_name: str
            worksheet_name: str
            information: str
            heading: str
            worksheet_url: str

        Status - string of additional info about searching of errors
        Example: 'From 01.01.1999 to 31.12.2000'
        """
        if not errors:
            return

        errors_sheet = self.get_spreadsheet_by_id(self.SPREAD_SHEET_ERRORS)

        time_of_writing = datetime.datetime.now()
        title_of_blank_errors = time_of_writing.strftime("%d-%m-%Y %H:%M:%S")

        cells = [Cell(row=1, col=3, value=status)]
        """
            -       |       -       |           S T A T U S         |       -       |       -       |
        Sheet titles|Worksheet title|     I N F O R M A T I O N     |    HEADING    |     U R L     |
        Sheet titles|Worksheet title|     I N F O R M A T I O N     |    HEADING    |     U R L     |
        Sheet titles|Worksheet title|     I N F O R M A T I O N     |    HEADING    |     U R L     |
        """

        for row, error in enumerate(errors, start=2):
            cells.extend(
                [
                    Cell(row=row, col=1, value=error.spreadsheet_name),
                    Cell(row=row, col=2, value=error.worksheet_name),
                    Cell(row=row, col=3, value=error.information),
                    Cell(row=row, col=4, value=error.heading),
                    Cell(row=row, col=5, value=error.worksheet_url)
                ]
            )

        new_error_worksheet = errors_sheet.add_worksheet(
            title=title_of_blank_errors,
            rows=len(errors) + 1,
            cols=5
        )

        new_error_worksheet.update_cells(cells)

        errors_sheet.batch_update(body={
            'requests': [
                {
                    "autoResizeDimensions": {
                        "dimensions": {
                            "sheetId": new_error_worksheet.id,
                            "dimension": "COLUMNS",
                            "startIndex": 0,
                            "endIndex": 5
                        }
                    }
                }
            ]
        })

        return self.get_url(new_error_worksheet.url)

    queue_of_errors_to_update = []
    queue_of_blanks_checked = []

    def mark_blank_as_checked(self, spreadsheet: Spreadsheet, errors: List[BlankError]):
        problematic_blanks_titles = set([error.worksheet_name for error in errors])
        worksheets = spreadsheet.worksheets()

        requests = []
        for worksheet in worksheets:
            requests.append(
                self.create_body_request_for_marking_blank(
                    worksheet=worksheet,
                    column=1,
                    row=1,
                    value='Перевірено'
                )
            )
            requests.append(
                self.create_body_request_for_marking_blank(
                    worksheet=worksheet,
                    column=1,
                    row=2,
                    value='Виявлено помилки' if worksheet.title in problematic_blanks_titles else 'Помилки відсутні'
                )
            )
        spreadsheet.batch_update(body={'requests': requests})

    @staticmethod
    def create_body_request_for_marking_blank(worksheet: Worksheet, column: int, row: int, value: str):
        return {
            # Automatically write value in the appropriate field
            'updateCells': {
                'fields': 'userEnteredValue',
                # Cell:
                'range': {
                    # Column:
                    "startColumnIndex": column - 1,
                    "endColumnIndex": column,
                    # Row:
                    "startRowIndex": row - 1,
                    "endRowIndex": row,
                    "sheetId": worksheet.id
                },
                'rows': [
                    {
                        'values': {
                            # Finally we enter this value
                            'userEnteredValue': {
                                'stringValue': value
                            }
                        }
                    }
                ],
            }
        }
